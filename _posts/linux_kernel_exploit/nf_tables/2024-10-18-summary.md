---
title: nf_tables summary
date: 2024-10-18 15:13:00 +0900
categories: [Linux Kernel Exploit, nf_tables]
tags: [linux kernel] # TAG names should always be lowercase
description: _
author: seadragnol
published: false
---

## Basic

The code is taken from linux kernel 6.11.4

### Tables

Tables are the top-level structures.\
They contain the chains.\
Chains can only jump to another chain on the same table.

Tables belongs to a particular family. The family defines what type of packets will be handled by the chains in the table.
The families are:

- `ip`: IPv4 packets
- `ip6`: IPv6 packets
- `inet`: both IPv4 and IPv6 packets
- `arp`: ARP-level traffic
- `bridge`: packets traversing bridges
- `netdev`: allows base chains to be attached to a particular network interface. such base chains will then see **all** network traffic on that interface. That means that ARP traffic can be handled from here as well. The `netdev` family is only used when the base chains of the table will use the `ingress` hook.

### Expressions

struct [nft_expr](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L404):

```c
/**
 *	struct nft_expr - nf_tables expression
 *
 *	@ops: expression ops
 *	@data: expression private data
 */
struct nft_expr {
	const struct nft_expr_ops	*ops;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

{: file='/include/net/netfilter/nf_tables.h#L404'}

struct [nft_expr_ops](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L938):

```c
/**
 *	struct nft_expr_ops - nf_tables expression operations
 *
 *	@eval: Expression evaluation function
 *	@clone: Expression clone function
 *	@size: full expression size, including private data size
 *	@init: initialization function
 *	@activate: activate expression in the next generation
 *	@deactivate: deactivate expression in next generation
 *	@destroy: destruction function, called after synchronize_rcu
 *	@destroy_clone: destruction clone function
 *	@dump: function to dump parameters
 *	@validate: validate expression, called during loop detection
 *	@reduce: reduce expression
 *	@gc: garbage collection expression
 *	@offload: hardware offload expression
 *	@offload_action: function to report true/false to allocate one slot or not in the flow
 *			 offload array
 *	@offload_stats: function to synchronize hardware stats via updating the counter expression
 *	@type: expression type
 *	@data: extra data to attach to this expression operation
 */
struct nft_expr_ops {
	void				(*eval)(const struct nft_expr *expr,
						struct nft_regs *regs,
						const struct nft_pktinfo *pkt);
	int				(*clone)(struct nft_expr *dst,
						 const struct nft_expr *src, gfp_t gfp);
	unsigned int			size;

	int				(*init)(const struct nft_ctx *ctx,
						const struct nft_expr *expr,
						const struct nlattr * const tb[]);
	void				(*activate)(const struct nft_ctx *ctx,
						    const struct nft_expr *expr);
	void				(*deactivate)(const struct nft_ctx *ctx,
						      const struct nft_expr *expr,
						      enum nft_trans_phase phase);
	void				(*destroy)(const struct nft_ctx *ctx,
						   const struct nft_expr *expr);
	void				(*destroy_clone)(const struct nft_ctx *ctx,
							 const struct nft_expr *expr);
	int				(*dump)(struct sk_buff *skb,
						const struct nft_expr *expr,
						bool reset);
	int				(*validate)(const struct nft_ctx *ctx,
						    const struct nft_expr *expr,
						    const struct nft_data **data);
	bool				(*reduce)(struct nft_regs_track *track,
						  const struct nft_expr *expr);
	bool				(*gc)(struct net *net,
					      const struct nft_expr *expr);
	int				(*offload)(struct nft_offload_ctx *ctx,
						   struct nft_flow_rule *flow,
						   const struct nft_expr *expr);
	bool				(*offload_action)(const struct nft_expr *expr);
	void				(*offload_stats)(struct nft_expr *expr,
							 const struct flow_stats *stats);
	const struct nft_expr_type	*type;
	void				*data;
};
```

{: file='/include/net/netfilter/nf_tables.h#L938'}

struct [nft_immediate_expr](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables_core.h#L55):

```c
struct nft_immediate_expr {
	struct nft_data		data;
	u8			dreg;
	u8			dlen;
};
```

{: file='/include/net/netfilter/nf_tables_core.h#L55'}

struct [nft_expr_type](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L887):

```c
/**
 *	struct nft_expr_type - nf_tables expression type
 *
 *	@select_ops: function to select nft_expr_ops
 *	@release_ops: release nft_expr_ops
 *	@ops: default ops, used when no select_ops functions is present
 *	@inner_ops: inner ops, used for inner packet operation
 *	@list: used internally
 *	@name: Identifier
 *	@owner: module reference
 *	@policy: netlink attribute policy
 *	@maxattr: highest netlink attribute number
 *	@family: address family for AF-specific types
 *	@flags: expression type flags
 */
struct nft_expr_type {
	const struct nft_expr_ops	*(*select_ops)(const struct nft_ctx *,
						       const struct nlattr * const tb[]);
	void				(*release_ops)(const struct nft_expr_ops *ops);
	const struct nft_expr_ops	*ops;
	const struct nft_expr_ops	*inner_ops;
	struct list_head		list;
	const char			*name;
	struct module			*owner;
	const struct nla_policy		*policy;
	unsigned int			maxattr;
	u8				family;
	u8				flags;
};
```

{: file='/include/net/netfilter/nf_tables.h#L887'}

At the time of writing there are only two expression type flags values, stateful (NFT_EXPR_STATEFUL) and garbage collectible (NFT_EXPR_GC)[^two-expression-type-flags] (Still true for version 6.11.4?: [source](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L902)).

### Registers

struct [nft_verdict](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L97):

```c
/**
 * 	struct nft_verdict - nf_tables verdict
 *
 * 	@code: nf_tables/netfilter verdict code
 * 	@chain: destination chain for NFT_JUMP/NFT_GOTO
 */
struct nft_verdict {
	u32				code;
	struct nft_chain		*chain;
};
```

{: file='/include/net/netfilter/nf_tables.h#L97'}

struct [nft_data](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L102):

```c
struct nft_data {
	union {
		u32			data[4];
		struct nft_verdict	verdict;
	};
} __attribute__((aligned(__alignof__(u64))));
```

{: file='/include/net/netfilter/nf_tables.h#L102'}

struct [nft_regs](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L119):

```c
#define NFT_REG32_NUM		20

/**
 *	struct nft_regs - nf_tables register set
 *
 *	@data: data registers
 *	@verdict: verdict register
 *
 *	The first four data registers alias to the verdict register.
 */
struct nft_regs {
	union {
		u32			data[NFT_REG32_NUM];
		struct nft_verdict	verdict;
	};
};
```

{: file='/include/net/netfilter/nf_tables.h#L119'}

enum [nft_registers](https://elixir.bootlin.com/linux/v6.11.4/source/include/uapi/linux/netfilter/nf_tables.h#L22):

```c
/**
 * enum nft_registers - nf_tables registers
 *
 * nf_tables used to have five registers: a verdict register and four data
 * registers of size 16. The data registers have been changed to 16 registers
 * of size 4. For compatibility reasons, the NFT_REG_[1-4] registers still
 * map to areas of size 16, the 4 byte registers are addressed using
 * NFT_REG32_00 - NFT_REG32_15.
 */
enum nft_registers {
	NFT_REG_VERDICT,
	NFT_REG_1,
	NFT_REG_2,
	NFT_REG_3,
	NFT_REG_4,
	__NFT_REG_MAX,

	NFT_REG32_00	= 8,
	NFT_REG32_01,
	NFT_REG32_02,
	NFT_REG32_03,
	NFT_REG32_04,
	NFT_REG32_05,
	NFT_REG32_06,
	NFT_REG32_07,
	NFT_REG32_08,
	NFT_REG32_09,
	NFT_REG32_10,
	NFT_REG32_11,
	NFT_REG32_12,
	NFT_REG32_13,
	NFT_REG32_14,
	NFT_REG32_15,
};
#define NFT_REG_MAX	(__NFT_REG_MAX - 1)

#define NFT_REG_SIZE	16
#define NFT_REG32_SIZE	4
#define NFT_REG32_COUNT	(NFT_REG32_15 - NFT_REG32_00 + 1)
```

{: file='/include/uapi/linux/netfilter/nf_tables.h#L22'}

enum [nft_verdicts](https://elixir.bootlin.com/linux/v6.11.4/source/include/uapi/linux/netfilter/nf_tables.h#L64):

```c
/**
 * enum nft_verdicts - nf_tables internal verdicts
 *
 * @NFT_CONTINUE: continue evaluation of the current rule
 * @NFT_BREAK: terminate evaluation of the current rule
 * @NFT_JUMP: push the current chain on the jump stack and jump to a chain
 * @NFT_GOTO: jump to a chain without pushing the current chain on the jump stack
 * @NFT_RETURN: return to the topmost chain on the jump stack
 *
 * The nf_tables verdicts share their numeric space with the netfilter verdicts.
 */
enum nft_verdicts {
	NFT_CONTINUE	= -1,
	NFT_BREAK	= -2,
	NFT_JUMP	= -3,
	NFT_GOTO	= -4,
	NFT_RETURN	= -5,
};
```

{: file='/include/uapi/linux/netfilter/nf_tables.h#L64'}

### Sets

document: [https://wiki.nftables.org/wiki-nftables/index.php/Sets](https://wiki.nftables.org/wiki-nftables/index.php/Sets)

struct [nft_set](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L575):

```c
#define NFT_SET_EXPR_MAX	2

/**
 * 	struct nft_set - nf_tables set instance
 *
 *	@list: table set list node
 *	@bindings: list of set bindings
 *	@refs: internal refcounting for async set destruction
 *	@table: table this set belongs to
 *	@net: netnamespace this set belongs to
 * 	@name: name of the set
 *	@handle: unique handle of the set
 * 	@ktype: key type (numeric type defined by userspace, not used in the kernel)
 * 	@dtype: data type (verdict or numeric type defined by userspace)
 * 	@objtype: object type (see NFT_OBJECT_* definitions)
 * 	@size: maximum set size
 *	@field_len: length of each field in concatenation, bytes
 *	@field_count: number of concatenated fields in element
 *	@use: number of rules references to this set
 * 	@nelems: number of elements
 * 	@ndeact: number of deactivated elements queued for removal
 *	@timeout: default timeout value in jiffies
 * 	@gc_int: garbage collection interval in msecs
 *	@policy: set parameterization (see enum nft_set_policies)
 *	@udlen: user data length
 *	@udata: user data
 *	@pending_update: list of pending update set element
 * 	@ops: set ops
 * 	@flags: set flags
 *	@dead: set will be freed, never cleared
 *	@genmask: generation mask
 * 	@klen: key length
 * 	@dlen: data length
 *	@num_exprs: numbers of exprs
 *	@exprs: stateful expression
 *	@catchall_list: list of catch-all set element
 * 	@data: private set data
 */
struct nft_set {
	struct list_head		list;
	struct list_head		bindings;
	refcount_t			refs;
	struct nft_table		*table;
	possible_net_t			net;
	char				*name;
	u64				handle;
	u32				ktype;
	u32				dtype;
	u32				objtype;
	u32				size;
	u8				field_len[NFT_REG32_COUNT];
	u8				field_count;
	u32				use;
	atomic_t			nelems;
	u32				ndeact;
	u64				timeout;
	u32				gc_int;
	u16				policy;
	u16				udlen;
	unsigned char			*udata;
	struct list_head		pending_update;
	/* runtime data below here */
	const struct nft_set_ops	*ops ____cacheline_aligned;
	u16				flags:13,
					dead:1,
					genmask:2;
	u8				klen;
	u8				dlen;
	u8				num_exprs;
	struct nft_expr			*exprs[NFT_SET_EXPR_MAX];
	struct list_head		catchall_list;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

{: file='/include/net/netfilter/nf_tables.h#L575'}

struct [nft_set_ops](https://elixir.bootlin.com/linux/v6.11.4/source/include/net/netfilter/nf_tables.h#L454):

```c
/**
 *	struct nft_set_ops - nf_tables set operations
 *
 *	@lookup: look up an element within the set
 *	@update: update an element if exists, add it if doesn't exist
 *	@delete: delete an element
 *	@insert: insert new element into set
 *	@activate: activate new element in the next generation
 *	@deactivate: lookup for element and deactivate it in the next generation
 *	@flush: deactivate element in the next generation
 *	@remove: remove element from set
 *	@walk: iterate over all set elements
 *	@get: get set elements
 *	@commit: commit set elements
 *	@abort: abort set elements
 *	@privsize: function to return size of set private data
 *	@estimate: estimate the required memory size and the lookup complexity class
 *	@init: initialize private data of new set instance
 *	@destroy: destroy private data of set instance
 *	@gc_init: initialize garbage collection
 *	@elemsize: element private size
 *
 *	Operations lookup, update and delete have simpler interfaces, are faster
 *	and currently only used in the packet path. All the rest are slower,
 *	control plane functions.
 */
struct nft_set_ops {
	bool				(*lookup)(const struct net *net,
						  const struct nft_set *set,
						  const u32 *key,
						  const struct nft_set_ext **ext);
	bool				(*update)(struct nft_set *set,
						  const u32 *key,
						  struct nft_elem_priv *
							(*new)(struct nft_set *,
							       const struct nft_expr *,
							       struct nft_regs *),
						  const struct nft_expr *expr,
						  struct nft_regs *regs,
						  const struct nft_set_ext **ext);
	bool				(*delete)(const struct nft_set *set,
						  const u32 *key);

	int				(*insert)(const struct net *net,
						  const struct nft_set *set,
						  const struct nft_set_elem *elem,
						  struct nft_elem_priv **priv);
	void				(*activate)(const struct net *net,
						    const struct nft_set *set,
						    struct nft_elem_priv *elem_priv);
	struct nft_elem_priv *		(*deactivate)(const struct net *net,
						      const struct nft_set *set,
						      const struct nft_set_elem *elem);
	void				(*flush)(const struct net *net,
						 const struct nft_set *set,
						 struct nft_elem_priv *priv);
	void				(*remove)(const struct net *net,
						  const struct nft_set *set,
						  struct nft_elem_priv *elem_priv);
	void				(*walk)(const struct nft_ctx *ctx,
						struct nft_set *set,
						struct nft_set_iter *iter);
	struct nft_elem_priv *		(*get)(const struct net *net,
					       const struct nft_set *set,
					       const struct nft_set_elem *elem,
					       unsigned int flags);
	void				(*commit)(struct nft_set *set);
	void				(*abort)(const struct nft_set *set);
	u64				(*privsize)(const struct nlattr * const nla[],
						    const struct nft_set_desc *desc);
	bool				(*estimate)(const struct nft_set_desc *desc,
						    u32 features,
						    struct nft_set_estimate *est);
	int				(*init)(const struct nft_set *set,
						const struct nft_set_desc *desc,
						const struct nlattr * const nla[]);
	void				(*destroy)(const struct nft_ctx *ctx,
						   const struct nft_set *set);
	void				(*gc_init)(const struct nft_set *set);

	unsigned int			elemsize;
};
```

{: file='/include/net/netfilter/nf_tables.h#L454'}

### Maps

document: [https://wiki.nftables.org/wiki-nftables/index.php/Maps](https://wiki.nftables.org/wiki-nftables/index.php/Maps)

You can think of a map as a set that returns a value instead of just an "in set / not in set" result. Behind the scenes both sets and maps use the same generic set infrastructure and therefore share many of the same options and semantics.

### Stateful Objects

documentation: [https://wiki.nftables.org/wiki-nftables/index.php/Stateful_objects](https://wiki.nftables.org/wiki-nftables/index.php/Stateful_objects)

## libraries

### libnftnl

examples: [https://git.netfilter.org/libnftnl/tree/examples](https://git.netfilter.org/libnftnl/tree/examples)

## References

- wiki: [https://wiki.nftables.org/wiki-nftables/index.php/Main_Page](https://wiki.nftables.org/wiki-nftables/index.php/Main_Page)
- quick reference: [https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes](https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes)
- [https://anatomic.rip/netfilter_nf_tables/](https://anatomic.rip/netfilter_nf_tables/)
- [http://web.archive.org/web/20240326193851/https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/](http://web.archive.org/web/20240326193851/https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/)

## Footnoot

[^two-expression-type-flags]: [https://www.nccgroup.com/us/research-blog/settlers-of-netlink-exploiting-a-limited-uaf-in-nf_tables-cve-2022-32250/#expressions](https://www.nccgroup.com/us/research-blog/settlers-of-netlink-exploiting-a-limited-uaf-in-nf_tables-cve-2022-32250/#expressions)
